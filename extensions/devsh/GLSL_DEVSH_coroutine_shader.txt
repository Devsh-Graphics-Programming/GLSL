Name

    EXT_ray_tracing

Name Strings

    GL_DEVSH_coroutine_shader

Contact
    Mateusz Kielan (devsh 'at' devsh.eu), DevSH Graphics Programming
Contributors

    Mateusz Kielan, DevSH Graphics Programming
    Krzysztof Szenk, DevSH Graphics Programming
    Legend, ?

Status

    Draft

Version

    Last Modified Date: 2021-02-09
    Revision: 1

Dependencies

    This extension can be applied to OpenGL GLSL versions 4.60
    (#version 460) and higher.

    This extension is written against revision 5 of the OpenGL Shading Language
    version 4.60, dated September 4, 2017.

    This extension interacts with revision 43 of the GL_KHR_vulkan_glsl
    extension, dated October 25, 2017.

    This extension interacts with GL_KHR_shader_subgroup.

    This extension interacts with GL_NV_shader_subgroup_partitioned.

    This extension interacts with GL_ARB_shader_ballot.

    This extension interacts with GL_ARB_shader_group_vote.

    This extension interacts with GL_ARB_shader_clock.

    This extension interacts with GL_EXT_shader_realtime_clock.

    This extension interacts with GL_KHR_memory_scope_semantics.

    This extension interacts with GL_EXT_nonuniform_qualifier.

    This extension interacts with GL_NV_shader_sm_builtins.

Overview

    This extension document modifies GLSL to add a shader stage to support stackful coroutines.
    They stage is called the coroutine stage.

    This extension document adds support for the following extensions to be used
    within GLSL:

    - GL_DEVSH_coroutine_shader - enables the coroutine stage.

    Mapping to SPIR-V
    -----------------

    For informational purposes (non-normative), the following is an
    expected way for an implementation to map GLSL constructs to SPIR-V
    constructs:

      coroutine shader -> CoroutineDEVSH Execution model

      somethingDEVSH storage qualifier -> SomethingDEVSH storage class

      gl_VirtualInvocationIDDEVSH -> VirtualInvocationIdDEVSH decorated OpVariable
      gl_InvocationsLaunchedDEVSH -> InvocationsLaunchedDEVSH decorated OpVariable
      gl_InvocationsEnqueuedDEVSH -> InvocationsEnqueuedDEVSH decorated OpVariable
      gl_InvocationsFinishedDEVSH -> InvocationsFinishedDEVSH decorated OpVariable

      enqueueCoroutineDEVSH -> OpEnqueueCoroutineDEVSH instruction
      awaitCoroutineDEVSH -> OpAwaitCoroutineDEVSH instruction
      continueWithCoroutineDEVSH -> OpContinueWithCoroutineDEVSH instruction

      coroutineDEVSH constructor -> OpConvertUToCoroutineDEVSH

      Any of the following built-in variables:
        - gl_SubgroupSize, gl_SubgroupInvocationID, gl_SubgroupEqMask,
          gl_SubgroupGeMask, gl_SubgroupGtMask, gl_SubgroupLeMask,
          gl_SubgroupLtMask,
        - gl_SubGroupSizeARB, gl_SubGroupInvocationARB, gl_SubGroupEqMaskARB,
          gl_SubGroupGeMaskARB, gl_SubGroupGtMaskARB, gl_SubGroupLeMaskARB,
          gl_SubGroupLtMaskARB
        - gl_WarpIDNV, gl_SMIDNV
      used in the coroutine shader should also
        - be decorated with Volatile if GL_KHR_memory_scope_semantics is not
          enabled
        - use the Volatile memory semantics for any OpLoad into one of these
          variables if GL_KHR_memory_scope_semantics is enabled

Modifications to the OpenGL Shading Language Specification, Version 4.60

    Including the following line in a shader can be used to control the
    language features described in this extension:

      #extension GL_DEVSH_coroutine_shader                          : <behavior>

    where <behavior> is as specified in section 3.3.
    New preprocessor #defines are added:

      #define GL_DEVSH_coroutine_shader                             1

Additions to Chapter 2 of the OpenGL Shading Language Specification
(Overview of OpenGL Shading)

    Add Section 2.13, Coroutine Processor

    The <coroutine processor> is a programmable unit that operates on arbitrary
    input data associated with a single invocation and is invoked in a possibly deferred
    way after previously being enqueud or continued by another coroutine in the coroutine stage.
    It is similar in concept to an indirect function call mechanism.
    It is executed and implemented using the compute pipeline.
    Compilation units written in the OpenGL Shading Language to run on this processor
    are called <coroutine shaders>.

    The coroutine processor can be invoked by the coroutine shader stage. They can access data passed
    in to the coroutine from the enqueueing or continuing coroutine, as well as read from and write to
    the Descriptors bindings usually available to the compute stage. They can be invoked by either
    being the starting coroutine for the coroutine dispatch or by being enqueued or continued into
    by a previously executing coroutines.
    
    Refer to Coroutine Shader chapter of the Vulkan specification for further details.

Changes to Chapter 3 of The OpenGL Shading Language Specification, Version 4.60

    Modify Section 3.6, (Keywords)

    (add the following to the list of reserved keywords)

    enqueueCoroutineDEVSH
    awaitCoroutineDEVSH
    continueWithCoroutineDEVSH

Changes to Chapter 4 of The OpenGL Shading Language Specification, Version 4.60

    Add following to Section 4.1 (Basic Types)

    Coroutine Opaque Types

    Types                           Meaning
    -----                           -------

    coroutineDEVSH                  A handle representing a function to call.




Interactions with GL_KHR_shader_subgroup

    If GL_KHR_shader_subgroup is supported, the following built-in variables
    are available in the ray generation, intersection, any-hit, closest-hit,
    miss, and callable shading languages:

        mediump in uint  gl_SubgroupSize;
        mediump in uint  gl_SubgroupInvocationID;
        highp   in uvec4 gl_SubgroupEqMask;
        highp   in uvec4 gl_SubgroupGeMask;
        highp   in uvec4 gl_SubgroupGtMask;
        highp   in uvec4 gl_SubgroupLeMask;
        highp   in uvec4 gl_SubgroupLtMask;

    and have the same sematics.

    Additionally, all the "Shader Invocation Group Functions" that are
    not listed as compute-only are available in the ray generation,
    intersection, any-hit, closest-hit, miss, and callable shading languages.

Interactions with GL_NV_shader_subgroup_partitioned

    If GL_NV_shader_subgroup_partitioned is supported, subgroupPartitionNV()
    and all the subgroupPartitioned*NV() builtin functions are available in
    the ray generation, intersection, any-hit, closest-hit, miss, and callable
    shading languages.

Interactions with GL_NV_shaders_sm_builtins

    If GL_NV_shader_sm_builtins is supported, the builtin variables added by
    this extension are available in the ray generation, intersection, any-hit,
    closest-hit, miss, and callable shading languages.

Interactions with GL_ARB_shader_ballot

    If GL_ARB_shader_ballow is supported, the builtin variables and functions
    added by this extension are available in the ray generation, intersection,
    any-hit, closest-hit, miss, and callable shading languages.

Interactions with GL_ARB_shader_group_vote

    If GL_ARB_shader_group_vote is supported, the builtin functions added by
    this extension are available in the ray generation, intersection, any-hit,
    closest-hit, miss, and callable shading languages.

Interactions with GL_ARB_shader_clock

    If GL_ARB_shader_clock is supported, the new timing functions added by
    this extension are available in the ray generation, intersection, any-hit,
    closest-hit, miss, and callable shading languages.

Interactions with GL_EXT_shader_realtime_clock

    If GL_EXT_shader_realtime_clock is supported, the new timing functions
    added by this extension are available in the ray generation, intersection,
    any-hit, closest-hit, miss, and callable shading languages.

Interactions with GL_EXT_nonuniform_qualifier

    If GL_EXT_nonuniform_qualifier is supported, arrays of
    accelerationStructureEXT can be indexed with non-unform integral
    expressions when they are decorated with the nonuniformEXT qualifier.

Interactions with GL_EXT_scalar_block_layout

    If GL_EXT_scalar_block_layout is supported, buffer blocks with
    a layout of shaderRecordEXT can also be laid out using the scalar
    block layout.

Interactions with GL_EXT_ray_flags_primitive_culling

    If GL_EXT_ray_flags_primitive_culling is supported, ray flags added
    by this extension can be used as flags for the 'rayflags' argument
    for traceRayEXT() call, or for comparing value to gl_IncomingRayFlagsEXT.

Issues

    1) Question

       RESOLVED : Yes, needs to be specified in shaders.

    2) Question

       Answer

Revision History

    Rev.  Date          Author     Changes
    ----  -----------   ------     -------------------------------------------
     1    2021-0X-XX    devsh      Initial Version
